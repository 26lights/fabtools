"""
Fabric tools for managing crontab tasks
"""
from __future__ import with_statement
from contextlib import closing

from tempfile import NamedTemporaryFile

from fabric.api import *
from fabtools.files import upload_template


def add_task(name, timespec, user, command):
    """
    Add a cron task
    """
    entry = '%(timespec)s %(user)s %(command)s\n' % locals()
    with NamedTemporaryFile() as script:
        cm = CrontabManager(script.name)
        cm.add_task(entry, entry)
        cm.write_crontab()
        upload_template('/etc/cron.d/%(name)s' % locals(),
            script.name,
            context={},
            chown=True,
            use_sudo=True)


def add_daily(name, user, command):
    """
    Add a cron task to run daily
    """
    add_task(name, '@daily', user, command)


def remove_task(name, timespec, user, command):
    """
    Remove a cron task
    """
    entry = '%(timespec)s %(user)s %(command)s\n' % locals()
    # FIXME: This is wrong, the remote cron file should be retrieved
    # instead of writing to a temp file.
    with NamedTemporaryFile() as script:
        cm = CrontabManager(script.name)
        cm.remove_task(entry, entry)
        cm.write_crontab()
        upload_template('/etc/cron.d/%(name)s' % locals(),
            script.name,
            context={},
            chown=True,
            use_sudo=True)


class CrontabManager(object):
    """
    Helper class to edit entries in user crontabs (see man 5 crontab)

    Based heavily on the UserCrontabManager from z3c.recipe.usercrontab.
    """
    prepend = '# START %s (generated by fabtools)'
    append = '# END %s (generated by fabtools)'

    def __init__(self, path):
        self.crontab = []
        self._path = path

    def read_crontab(self):
        with closing(open(self._path, 'r')) as f:
            self.crontab = [l.strip("\n") for l in f]

    def write_crontab(self):
        with closing(open(self._path, 'w')) as f:
            for l in self.crontab:
                f.write("%s\n" % l)
            f.flush()

    def __repr__(self):
        return "\n".join(self.crontab)

    def find_boundaries(self, name):
        start = None
        end = None
        for line_number, line in enumerate(self.crontab):
            if line.strip() == self.prepend % name:
                if start is not None:
                    raise RuntimeError("%s found twice in the same crontab. "
                                       "Fix by hand." % (self.prepend % name))
                start = line_number
            if line.strip() == self.append % name:
                if end is not None:
                    raise RuntimeError("%s found twice in the same crontab. "
                                       "Fix by hand." % (self.append % name))
                end = line_number + 1
                # ^^^ +1 as we want the range boundary and that is behind the
                # element.
        return start, end

    def has_entry(self, name):
        """
        Check if the crontab has an entry
        """
        start, end = self.find_boundaries(name)
        return start is not None and end is not None

    def add_entry(self, name, entry):
        """
        Add an entry to the crontab.

        Find lines enclosed by APPEND/PREPEND, zap and re-add.
        """
        start, end = self.find_boundaries(name)
        inject_at = -1 # By default at the end of the file.
        if start is not None and end is not None:
            # But preferably in our existing location.
            self.crontab[start:end] = []
            inject_at = start
            # There is some white space already, so we only insert
            # entry and markers.
            to_inject = [self.prepend % name, entry, self.append % name]
        else:
            # Insert entry, markers, and white space
            to_inject = ['', self.prepend % name, entry, self.append % name]

        if inject_at == -1:
            # [-1:-1] would inject before the last item...
            self.crontab += to_inject
        else:
            self.crontab[inject_at:inject_at] = to_inject

    def del_entry(self, name):
        """
        Remove an entry from a crontab.
        """
        start, end = self.find_boundaries(name)
        if start is not None and end is not None:
            if start > 0:
                if not self.crontab[start - 1].strip():
                    # Also strip empty line in front.
                    start = start - 1
            if end < len(self.crontab):
                if not self.crontab[end].strip():
                    # Also strip empty line after end marker.
                    # Note: not self.crontab[end + 1] as end is the location
                    # AFTER the end marker to selected it with [start:end].
                    end = end + 1
            if end == len(self.crontab):
                end = None # Otherwise the last line stays in place
            self.crontab[start:end] = []
            return 1 # Number of entries that are removed.

        # Nothing removed.
        return 0
